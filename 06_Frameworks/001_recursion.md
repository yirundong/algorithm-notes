## 递归概述
> 递归就是递归,是一种在函数内部调用自己的基础结构.

**递归**在**物理**层面使用函数调用栈,我们在转化递归为非递归时也往往使用栈(当然可以不使用栈).栈的“后入先出”特性天然适合递归的结构,在函数调用栈中,递归函数每调用一次自己就会往栈中压入一层栈帧, 用来保存函数上下文(用以维护函数执行).函数返回后释放栈帧.

相较于**非递归**结构,递归中系统调用栈的基本单位“栈帧”是很大的(1KB左右),相较于代码中自定义栈的基本单位要大很多,并且维护/创建栈帧也需要更多时间.所以通常我们认为递归的时/空复杂度都是相对更差的.同时jvm中栈是很小的,不停的压栈会导致“栈溢出”,所以递归的深度是有限制的.相对来说,堆内存则要大很多.但是在算法题中,基本上不会有爆栈的情况,可以安心使用递归.递归的逻辑和思路往往都会更好.

算法中,用“迭代”作为递归的“反义词”,因为迭代是在一层函数栈帧中折腾更新变量.它俩都是重复一段逻辑的不同方法.

不要深入递归,人脑无法压入那么多栈(无法保存栈帧),递归主要关心逻辑与终止条件.递归本质上就是一种依赖关系,我们可以把递归抽象为一种上层依赖下层的层次结构,便于理解.

同时也可以使用“尾递归”来优化递归,当编译器发现上层栈帧不需要保留时就会直接释放(例如最后是`return f(xxx);`).这样函数调用栈中就只有一层栈帧.

## 使用递归的结构

### 二叉树的深度遍历

这是典型的使用递归的例子,同时我们也实现了不用递归的版本.同时我们知道这个递归是一种没有返回值的递归,如果我们加上返回值,就是我们说的“二叉树子树信息回收框架”.这个框架不仅完美利用了递归的特性,并且还是一种“树形DP”,复杂度非常好.我们往往使用这个框架去获取整棵树的属性.这种框架可以理解为“后序遍历且操作节点”,通常复杂度都为O(n).
