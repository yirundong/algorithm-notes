# 复杂度

复杂度是对算法的评估标准,因为同一个常数时间操作在不同的机器上会有不同的时间,不同的语言和架构对不同数据结构的内存占用也不一样,所以我们没有办法用实际使用的具体时间空间来描述这种通用的算法的,所以我们往往不在乎常数时间操作,而使用在数据量很大时(数据量小时看不出来好坏,相当于放大算法的优劣),时空占用随输入的变化而变化的幅度来说明算法的好坏,这就是复杂度的分析,所以不要再用时间来评估算法的好坏了,除非是在相同的环境中纵向对比

## 时间复杂度

用T(n)表示一个算法输入为n时所用的时间,这里的单位1是一次常数时间操作(例如加减乘除等等可以在固定时间解决的操作,即不受输入规模影响的操作)所用的时间,这是很具体的指标,当数据量很大时,除了最高阶之外的所有项都可以被忽略,这个最高阶就是时间复杂度的评判标准,我们通常用`T(n) <= f(x)`,f(x)就是最差情况所用的时间方程,我们就往往通过这个方程来估计时间复杂度,实际上我们说时间复杂度往往说的就是最差情况下,但是如果能通过数学方法`比如说概率`获得准确的平均情况下的时间方程,那肯定更好,最好情况基本不用,生活中也有很多这种例子,譬如说要去外地上学,路费宁可多要,才能应对可能遇到的坏情况,不然就完蛋了

## 空间复杂度

空间复杂度是一个算法中我们要额外申请的空间,这里的单位1也是指的可以用固定的数据占用内存空间(即不受输入规模影响的空间使用),用户本来就准备的不算在里面,空间复杂度在实际中重要性没有时间复杂度重要,我们优先考虑时间复杂度,毕竟现在硬盘便宜,而时间是很宝贵的,通常我们的空间都是被栈使用的,在使用递归的时候是使用的系统栈,自己也可以实现栈,系统栈是有限度的,所以说递归会有爆系统栈分配内存的风险,所以在实际中我们往往使用自己在内存中实现的栈结构,内存多大就可以用多大,空间复杂度尽量估计的大一点,因为要考虑扩展性等方面

## 怎么计算复杂度

1. 数学严格证明,这是最正确最科学的方法,在很多种情况下,用数学证明是最直观的,也就是先写出T(n),再取最高项.
2. 简单的可以看出来.
3. 可以通过图像观察复杂度,使用数形结合的思想,结合复杂度曲线.
4. 通过逻辑分析,这也是最抽象的一种方法.
5. 大多数情况都是用最差情况估计,有的可以用数学方法(比如概率)算出平均情况下的.
6. 复杂度一定是整体算法的复杂度,你要把整体算法的T(n)差不多表示出来,才能看出O(n),不要局部分析.

## 还有一件事...

在算法的设计中,往往会有一些潜规则,比如说log不带底就默认以2为底,这是因为计算机是2进制的,最常遇到的就是二叉树这样的结构,并且很多数据都是用2的幂,log以2为底太常见了,所以说默认不写了.

一般我们在写题中会有一个时间要求,如果写的算法时间复杂度太差就会超时,一般怎么估计呢?这个和你使用的语言有关系,一般认为cpp是1s,Java是2~3s,一般就是常数时间的操作要小于一个亿次,即10的8次幂次,我们可以据此由给定输入数据规模估计我们写的算法时间复杂度,比如数据规模n是10的2次幂,那么我们所写算法的时间复杂度最多应该在n的4次幂

等差数列的n项和是一个最高项是n2的式子

同时在算法中笼统的分结构的话,一般分为递归和迭代,所谓递归就是使用系统栈保存变量之前n代的数据,用的时候拿出用,相当于历史记录,所谓“递”就是往系统栈中放,“归”就是往外拿来用.而迭代就是立即改变,变量的历史记录不会被保存,重复执行某个逻辑,冲刷某个变量n次.所以说一般迭代是优于递归的,空间复杂度好很多.

递归一定可以改为非递归,其实就是我们常说的把系统栈变为我们自己申请的栈

## 递归

递归表示一种依赖关系,不用关注整体的流程,只要逻辑是对的就行,关注系统栈的行为是非常复杂而且没有必要的(亲身经历),你只要知道递归是用的系统栈即可,我们只需要注意递归关系即可,那是唯一重要的,可以这么说,递归就是逻辑.千万不要想的太复杂了,实际上就是很简单的逻辑.本身就是走一步看一步的.