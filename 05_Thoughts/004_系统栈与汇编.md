## 函数调用的机器级表示---系统栈

- 每个函数在系统栈上都会有一个栈帧
- 这里用32位机器进行解说
- <img src="https://gitee.com/yirundongsimgsbed/images/raw/master/img/img_2.png" alt="img_2" style="zoom: 80%;" />
  - 内存分为内核态和用户态,1:3分配
  - 栈和堆对向发展,中间有共享库
  - 局部变量在栈中,用完即逝
  - 堆中是动态分配的内存,对象一般在堆中  - bss区是存储未初始化的全局变量和静态变量,他们有默认的初始值,用的时候会自动赋值
  - data区存储已初始化的全局变量和静态变量
  - 文本区存放函数,数组,字符串等不可变的数据
  - 还有一部分预留空间,以及因为内存对齐原因有一部分没有用完
  - 内存对齐是为了寄存器可以以最少的次数拿完数据,典型的以空间换时间
- 涉及到三个寄存器---ebp(记录栈帧底指针),esp(记录栈顶指针),ip寄存器(记录下一条执行的指令)
- call,ret汇编指令
  - call将ip寄存器中的指令压栈备份到调用函数栈帧的顶部,同时更新ip为调用函数的第一条指令
  - ret指令就是从栈顶拿到ip旧值,恢复ip寄存器
- push,pop汇编指令
  - push是esp减4,再进栈
  - pop是先出栈放入指定位置,再esp加4
- 汇编中的定义变量使用mov指令实现的
- 栈帧的切换:
  - 加一个栈帧:
    - push ebp<br>mov ebp,esp<br>
    - 相当于先备份上一个栈帧的栈底指针到新栈帧的栈底,然后更新栈底指针
    - 所有函数开头都会这样,可以直接用enter指令,比较方便
  - 减一个栈帧:
    - mov esp,ebp<br>pop ebp
    - 相当于先让esp指向栈底,然后把栈底出栈到ebp(更新ebp为上一个栈帧的栈底)
    - 此时esp指向的内容是调用函数的下一句,就是调用结束之后要执行的指令
    - 等同于leave指令
  - 所以enter指令是加入栈帧,leave指令是减少栈帧,每个栈帧的底记录的是上一个栈帧的底的地址,顶是IP寄存器的旧值
  - 栈帧中有什么?
    - 局部变量在栈帧底部区域
    - 传给被调用函数的参数在栈帧顶部区域
    - 越在前面越靠近栈顶
    - 因为要对齐(gcc: 16B的整数倍),所以会有空闲不用的区域
    - 所以参数才可以在不同函数之间传递,因为他们都在一个栈中

每次调用一个函数就会压入相应的栈帧到系统栈中,栈帧中是这个函数所需要的资料,当函数返回之后栈帧会弹出,递归会用到系统栈来保存未结束函数的环境,递归只是一种依赖关系,相当于分治法,系统栈只是辅助递归保存上层递归函数信息的容器而已.不使用系统栈,我们也可以自己申请栈结构完成递归逻辑.