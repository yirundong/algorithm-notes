# 一些基础的排序

## 简介

### 默认顺序

这里所有的排序算法都是从小到大排序

### 内排序和外排序

这里所有的排序算法都是内排序,即数据没有那么大,可以一次性都放入内存中进行排序的,相对比较快和简单.

与之相对的是外排序,即涉及到资源限制,一台机器的内存一下子放不下这么多数据,需要外存辅助排序,需要将大文件分成若干个小文件分别排序分治,最后合并结果的排序,外排序相对比较慢和麻烦.

### 排序稳定性

我们排序时通常根据元素的某个特性排序,除此之外元素还会有很多别的特性,我们往往会希望比较特性相等的元素在排完序之后的顺序和它排序之前顺序一致,就比如说原来的顺序本来就是用另外一个特性排好序的,我们不希望这次排序打乱之前的顺序.排序算法的稳定性指的就是不会打乱相等的元素之前顺序的特性.一般来说,有稳定性的排序算法会优秀一点.

### Arrays.sort

我们用来作对比的排序算法---Java提供的数组排序算法,大致上是这个思路,实际上会更复杂,这里仅供参考

如果是基础类型数组,因为压根不需要稳定性,所以用的是最快的快速排序,但是当数据量<60时使用插入排序,因为快速排序时间复杂度好,也就是规模大时比较好,但是插入排序虽然时间复杂度不好,但是常数时间比较好,在数据规模小时比较优秀

如果是引用数组,会使用归并排序,因为这是所有高级排序中唯一有稳定性的

### 估计复杂度

这些算法都是很经典的算法,复杂度基本上都是最优的了,不同使用场景使用不同的算法,当遇到限定复杂度的算法问题时,去考虑能否实现时,可以想一想这些算法的设计者都没实现,这真的能实现吗,我们通常可以通过这些算法来估计解决具体问题的复杂度边界值,即最好能做到的程度.

---



## 基于比较的排序
### 基础四大排序

> 他们的时间复杂度是O(n2),比较差,实现起来也比较简单

#### 选择排序

##### 思路:

子数组的头不断后延,用两两比较法*选择*出该子数组中最小的,放入子数组开头

##### 代码:

```Java
public static void selectionSort(int[] arr){
    for (int i = 0; i < arr.length-1; i++){
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++){
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr,i,minIndex);
    }
}
```

##### 算法分析:

时间复杂度:每次选择的区间大小是等差数列,且都会依次遍历完,所以是 O(N2)

空间复杂度:这是一个原地排序,复杂度为O(1)

稳定性:情景:[4a, 3, 4b, 2],第一次排序直接变成[2, 3, 4b, 4a],所以不稳定

评价:这是最拉的排序算法,时间复杂度又高还不稳定,拉中之拉

#### 冒泡排序

##### 思路:

简而言之就是两两比较,大者上升,很像烧开水冒泡的过程,有点像反过来的选择排序,每次确定一个最大值,子数组的尾逐次前移

##### 代码:

```java
public static void bubbleSort(int[] arr){
    for (int e = arr.length - 1; e > 0; e--) {
        for (int i = 0; i < e; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
            }
        }
    }
}
```

##### 算法分析

时间复杂度:实际上是反过来的选择排序,时间复杂度O(N2)

空间复杂度:这是一个原地排序,复杂度为O(1)

稳定性:只要代码中两两相等时不交换就是稳定的,所以是可以做到稳定性的

评价:这个比选择排序稍微好一点,因为可以具有稳定性,但还是差的排序算法

#### 插入排序

##### 思路:

插入排序很像玩扑克牌时往手牌中插入的过程,即一张牌会和所有的手牌依次两两比较,如果发现比较小就会交换,最终牌堆中无序的牌会变为有序的手牌

##### 代码:

```Java
public static void insertionSort(int[] arr){
    for (int i = 1; i < arr.length; i++) {
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            swap(arr, j, j + 1);
        }
    }
}
```

##### 算法分析:

时间复杂度:它的常数是非常好的,因为只要它被插入到正确的位置之后就不会再动了,但是复杂度还是 O(N2),所以一般数据量不大时用插入排序

空间复杂度:这是一个原地排序,复杂度为O(1)

稳定性:可以做到稳定性,只要插入时,遇到相同的不交换就是稳定的

评价:这是一个很实用的算法,常数时间非常省,适合做小规模的排序

#### 希尔排序

##### 思路:

希尔排序是对插入排序的改良,可以增强时间复杂度

因为插入排序的T(n)和顺序是有很大关系的,在原数组有序时,最好时间复杂度甚至是线性的,所以希尔排序的思想就是粗糙化,进行多轮预处理,而预处理的代价是很低的,将原数组尽量做到有序,这样在最后一轮真正的插入排序时的T(n)会很小

通过一系列从大到小的步长,把原数组分为若干个数对,把数对用插入排序进行排序,最后的步长是1,此时就是插入排序

名字是根据发明者的名字来的,shell排序的时间复杂度是和步长有关系的,事实上发明者shell它设计的步长是从n/2,n/4...1,它不能改变插入排序的时间复杂度,即还是 O(N2),但是后人进行步长的改进,可以做到O(n^1.3^),

##### 代码:

```java
public static void shellSort(int[] arr) {
    int[] step = { 5, 2, 1 };
    for (int k : step) {
        for (int i = k; i < arr.length; i++) {
            for (int j = i - k; j >= 0 && arr[j] > arr[j + k]; j -= k) {
                swap(arr, j, j + k);
            }
        }
    }
}
```

##### 算法分析:

时间复杂度:有很多种,具体在网上查,这里略...

空间复杂度:这是一个原地排序,复杂度为O(1)

稳定性:不稳定,数对的排序是独立的,可以认为预处理都是独立的处理若干数对的

评价:shell排序使用,证明起来比较麻烦,并且时间复杂度也没有其他基于比较的高级排序O(nlogn)好,所以实际上用的比较少,可以看作是一个插入排序增强版,比较适合做中等规模的排序

------



### 高级三大排序

> 他们的时间复杂度是O(nlogn)的,这就已经是对数据本身不做要求的排序能做到的最好的了,三个各有优缺点,按需选择

#### 归并排序

##### 思路:

归并排序是一个典型的递归分治算法,也是对递归的一个很好的诠释,前递后归,先是不断的分为两个等规模的子数组,这是“递”,分到不能再分就“归”,当数据量很小时排序就相当容易了,把小数组排好再合并成大数组

##### 代码:

> 任何递归都可以改为非递归!

1. 递归版

   ```Java
   public static void mergeSort1(int[] arr) {
       if (arr == null || arr.length < 2) {
           return;
       }
       process(arr, 0, arr.length - 1);
   }
   
   public static void process(int[] arr, int L, int R) {
       if (L == R) {
           return;
       }
       int mid = L + ((R - L) >> 1);
       process(arr, L, mid);
       process(arr, mid + 1, R);
       merge(arr, L, mid, R);
   }
   
   public static void merge(int[] arr, int L, int M, int R) {
       int[] help = new int[R - L + 1];
       int i = 0;
       int p1 = L;
       int p2 = M + 1;
       while (p1 <= M && p2 <= R) {
           help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
       }
       while (p1 <= M) {
           help[i++] = arr[p1++];
       }
       while (p2 <= R) {
           help[i++] = arr[p2++];
       }
       for (i = 0; i < help.length; i++) {
           arr[L + i] = help[i];
       }
   }
   ```

   

2. 迭代版

   ```Java
   public static void mergeSort2(int[] arr) {
       if (arr == null || arr.length < 2) {
           return;
       }
       int N = arr.length;
       int mergeSize = 1;
       while (mergeSize < N) {
           int L = 0;
           while (L < N) {
               if (mergeSize >= N - L) {
                   break;
               }
               int M = L + mergeSize - 1;
               int R = M + Math.min(mergeSize, N - M - 1);
               merge(arr, L, M, R);
               L = R + 1;
           }
           if (mergeSize > N / 2) {
               break;
           }
           mergeSize <<= 1;
       }
   }
   ```

   迭代版的思路就是设置对比数组对,这个数组对中单个数组的长度从1一直到“逼近原数组长度N的最大2的幂”,对比组每变化一次都要遍历一次数组,只对数组对独立的进行排序,最终肯定能排好

##### 算法分析:

时间复杂度:

- 递归版:使用master公式进行分析,我们先看合并代价,也就是merge操作所用的时间,Merge操作不回退,实际上就相当于遍历数组,时间复杂度是O(n)的,所以时间复杂度是O(NlogN)

- 非递归版:对比组长度变化logn次,每一次变化都会遍历数组中所有的对比组进行merge,那么一次遍历整体的merge操作就是O(n)的,所以时间复杂度是O(NlogN)

空间复杂度:

- 递归版:需要额外申请一个等长的help数组,空间复杂度是O(n)
- 非递归版:实际上和你的做法有关,完全可以做到复用一个等长的help数组,空间复杂度是O(n),只不过我这个没有优化.

稳定性:可以做到稳定,只需要merge时先放左再放右即可.

评价:这个算法的价值在于其稳定性,他是这三个高级算法中唯一可以做到稳定性的,但是他空间复杂度是O(n),这点不好.

#### 快速排序

##### 思路:

快排是这三种高级排序中最快的,尽管时间复杂度都一样,但是它的常数时间好,这是经过大量实验验证过的.这也是它名字的由来,快排的时间复杂度是由概率算出来的平均时间复杂度,这种复杂度只有每轮partition(分区)都是随机的pivot(基准值)才能做到.否则只能用最差时间复杂度O(n2).

快排的核心思想就是多轮分区,数组每个值都和和pivot比大小,分出`<数组`和`>数组`.<数组放在pivot左边,>数组放在pivot右边.我们再用同样的方式再在每一个子数组中分出两个子数组,循环往复直到某个子数组不能再分就结算这个数组.这么做肯定把pivot的值放在了正确的位置,我们这么做数组中每个值都会作一次pivot的,所以能排好整个数组.

这里采用的partition是荷兰旗问题的解法,返回值是pivot最终被放好位置的索引,因为可能有多个与pivot值相等的数据,所以返回值是一个表示范围的数组.

##### 代码:

```Java
public class QuickSort {
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public static int[] partition(int[] arr, int L, int R) {
        if (L > R) {
            return new int[]{-1, -1};
        }
        if (L == R) {
            return new int[]{L, R};
        }
        int less = L - 1;
        int more = R;
        int index = L;
        while (index < more) {
            if (arr[index] == arr[R]) {
                index++;
            } else if (arr[index] < arr[R]) {
                swap(arr, index++, ++less);
            } else {
                swap(arr, index, --more);
            }
        }
        swap(arr, more, R);
        return new int[]{less + 1, more};
    }

    //递归版
    public static void quickSort1(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    public static void process(int[] arr, int L, int R) {
        if (L >= R) {
            return;
        }
        swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
        int[] equalArea = partition(arr, L, R);
        process(arr, L, equalArea[0] - 1);
        process(arr, equalArea[1] + 1, R);
    }

    public static class Op {
        public int l;
        public int r;

        public Op(int left, int right) {
            l = left;
            r = right;
        }
    }

    //非递归版
    public static void quickSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int N = arr.length;
        swap(arr, (int) (Math.random() * N), N - 1);
        int[] equalArea = partition(arr, 0, N - 1);
        int el = equalArea[0];
        int er = equalArea[1];
        Stack<Op> stack = new Stack<>();
        stack.push(new Op(0, el - 1));
        stack.push(new Op(er + 1, N - 1));
        while (!stack.isEmpty()) {
            Op op = stack.pop();
            if (op.l < op.r) {
                swap(arr, op.l + (int) (Math.random() * (op.r - op.l + 1)), op.r);
                equalArea = partition(arr, op.l, op.r);
                el = equalArea[0];
                er = equalArea[1];
                stack.push(new Op(op.l, el - 1));
                stack.push(new Op(er + 1, op.r));
            }
        }
    }
}
```

##### 算法分析:

时间复杂度:

- partition肯定是O(n),是线性操作,相当于遍历数组中每个值然后把其划分到某个区域.

- 那现在应该考虑的是要进行多少次分区操作
- 最差时间复杂度:当给定数组本身就有序时,并且每次的pivot刚好是最后一个值时,那你会进行n轮partition,所以时间复杂度是O(n2).
- 当然可能会想不通很正常,可以这么想,会进行n轮分区,每轮遍历的数组长度从1到n,我们均摊一下,把大数组的数据分给小数组,是不是相当于每轮都遍历了n/2长度的数组呢.
- 或者严格用数学公式求和,在最差情况下,快排的过程就相当于遍历n个数组,长度从1到n.时间复杂度是O(n2)
- 最好时间复杂度:每轮分区的pivot都正好在正中间,那样就是一个二分递归问题,又因为把大问题分成两个小问题的算法partition的时间复杂度是O(n)的,所以根据master公式可得最好时间复杂度是O(nlogn)的.
- 实际上我们的算法的pivot取数组中任意位置值的概率都是1/n的,是等概率的,我们可以用数学的方法考虑所有情况求出期望,这就是我们的平均时间复杂度,是O(nlogn).它是经过严格数学推导的,我们不需要证明,感兴趣可以自己看.
- 综上,快排的时间复杂度是平均时间复杂度,是O(nlogn).

空间复杂度:

- 我们要知道为什么要递归,递归实际上就是把某个变量的数据做一个git,也就是保存住这个变量在某个状态的值.
- 物理过程就是往系统栈(call stack)中压入值.
- 在快排过程中,就是不停的记录partition的返回值,也就是pivot的最终索引位置,以此来确定接下来我该处理那个子数组.
- 从栈中弹出一个值就是要结算这个位置,表示我已经处理完了这个数组,这个位置区间上的所有值都已经被放到正确的位置了,事实上这就是一种二叉树的深度优先遍历(dfs).
- 对于空间来说,最好情况和最差情况和时间一样.
- 最差情况下,所有情况都集中在二叉树的某一个分支,相当于链表,最差空间复杂度是O(n).
- 最好情况下,是一棵平衡二叉树,最好空间复杂度是O(logn).
- 当然,和时间一样,通过严格的数学证明,平均空间复杂度是O(logn).
- 综上,快排的空间复杂度是平均空间复杂度,是O(logn).

稳定性:

不能做到稳定性,取pivot的过程就相当于随机取一个位置的值和最后一个值交换,最终换回来也是把它和大于区的第一个交换,它是必然会破坏pivot原先的位置关系的.

评价:

递归版和非递归版实际上原理是一样的,只不过实现栈的手法不一样,一个是系统栈,一个是自己申请的数据结构,复杂度是一样的.快排是非常快的,实现起来也简单,所以很常用,它的优势就在于快,缺点就是它不稳定,时间复杂度也不是最好的.快排是很有启发性的算法,值的多看几遍.

课外补充:

有没有可能存在所谓“时间复杂度为O(n)的01问题的稳定原地排序”呢,实际上有一篇论文“01 stable sort”专门讲这个,但是非常复杂并且对数据也做了限定,这个和partition类似,但是partition是不稳定的.我们可以这么想,连快排这样著名的算法都没有实现,那肯定是实现不了,至少是不完美,不能应对所有的情况.

#### 堆排序

##### 思路:

1. 从上往下建堆
   先把数组一个一个加进堆中,建成一个大根堆,再把堆顶和堆尾的值交换,把heapSize减1,让堆顶最大值放到最后,然后调整剩余的堆结构.循环这组操作,最终可以排好序.
2. 从下往上建堆
   

##### 代码:

```Java
public class HeapSort {
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    public static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }
    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // O(N*logN),从上到下建堆
//    for (int i = 0; i < arr.length; i++) { // O(N)
//       heapInsert(arr, i); // O(logN)
//    }
        // O(N),从下到上建堆
        for (int i = arr.length - 1; i >= 0; i--) {
            heapify(arr, i, arr.length);
        }
        int heapSize = arr.length;
        swap(arr, 0, --heapSize);
        // 排序,O(N*logN)
        while (heapSize > 0) { 
            heapify(arr, 0, heapSize); 
            swap(arr, 0, --heapSize); 
        }
    }
}
```

##### 算法分析:

时间复杂度:

堆排序的时间复杂度分析分为两部分,第一是建堆,第二是排序.

建堆完成之后,就是n轮`交换头尾,修好余堆`的排序过程,这个过程两种方法都是一致的.

1. 从上到下建堆

   简单的说如果有N个数,每个数都进行heapInsert这样时间复杂度O(logn)的操作,那时间复杂度就是O(nlogn).

   这个比较难以理解,因为实际上这个操作的T(n) = log1 + log2 + log3 + … +logN的,数学可以具体求出来,它的最高阶就是nlogn级别的

   你也可以结合图像理解,因为常数项不影响时间复杂度分析,所以我们设输入为2n,那这样T(2n)就是log1 + log2 + log3 + … +log2N,logn图像增长非常缓慢,我们把距离中心logn相等的值求平均值,那样基本上求和就相当于2nlogn,小于但不会小很多,相当于一点几个nlogn,当输入量的常数项取更多时就更逼近了,所以时间复杂度肯定是O(nlogn)的.

2. 从下往上建堆

   从给定数组最后一个开始倒着heapify,因为是堆,所以叶子节点数量差不多n/2个,有一层子节点的节点数量是n/4,有两层子节点的节点数量n/8......

   我们认为遍历数组元素算一个常数时间,然后一层的heapify时间是固定的,算一个常数时间.

   这样我们可以得到T(n) = n/2 * 1 + n/4 * 2 + n/8 * 3 + ...... 1 * logn.

   这种等差加等比的组合问题求解是典型的高中数学,我们使用可以得到2T(n),然后错位相减得出结果,时间复杂度是O(n)的.

   不要觉得每层节点个数不对,实际上完全二叉树的叶节点数量就是(n+1)/2.只有一层子节点的节点数是((n - (n+1)/2) + 1) / 2,千万别化简,整数除法是向下取整的,化简了就不对了.你可以把有k层子节点的节点数都算出来,基本上都是大差不差的,你可以自己去试一试,基本上差1个左右.

   这样的话可以把建堆的时间复杂度优化为O(n),但是对数据有要求,需要一次性把数组全给我,我一次性建好堆以后不加了,才能做到这个复杂度.这个做法不是很灵活,不能动态建堆,但是时间复杂度好.

3. 排序
   这个时间复杂度的分析和从上到下建堆很像,最差情况下会进行n轮从顶到底的heapify.T(n) = log1 + log2 + log3 + … +logN,我们的分析也一样,所以排序时间复杂度是O(nlogn).

4. 因为排序的时间复杂度是O(nlogn),所以不论是怎么建堆的,总体上时间复杂度是O(nlogn),

空间复杂度:

- 堆排序是一种原地排序算法,空间复杂度是O(1).

稳定性:

- 堆排序是做不到稳定性的,我们这么想,如果原数组中有两个最大值,那么他们进堆之后,在堆中的顺序还是不变的,不过一旦头尾互换之后,它们的相对位置肯定会互换,所以我们讲堆排序是做不到稳定性的.

评价:

- 堆排序最大的优点是空间复杂度好,是一种原地排序算法.适合需要节省空间的情况.

---



## 基于特定数据的非比较排序

> 桶排序:这是以下两种算法的核心思想,就是安排一个桶数组,把数组中的值按照规则放进不同的桶中,然后在桶中进行排序,最后按照桶的顺序把数据依次拿出来放进结果数组中.如果桶中排序是稳定的,例如插入排序,那么桶排序就是稳定的.以下两种算法都属于桶排序.桶排序适合那些值非常多,但是经过某种规则可以均匀放进比数据数量小的多的桶数组中的数据.
>
> 如果不算桶内排序和放入规则的复杂度的话,那这种排序方法是没有比较的,就是所谓“各得其所”,只需要遍历原数组,然后放到各自对应的桶中即可,最后依次拿出,时间复杂度是O(n).
>
> 虽说时间复杂度可能会比较好,但是规则的制定是难点,对数据本身有要求,没有比较排序那么通用,需要数据本身可以指定规则,然后还需要桶内排序算法和放入规则算法的时间复杂度不能高于比较排序,并且桶的数量不能太多,不然空间复杂度太高.
>
> 可以说它可以做到时间复杂度是O(n)的排序,但是要求比较多,一般来说我们仅对数字数组考虑桶排序这样的非比较排序.

#### 计数排序

##### 思路:

桶数组的下标表示数,其值表示该数的个数.

##### 代码:

```Java
public static void countSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int max = Integer.MIN_VALUE;
    for (int k : arr) {
        max = Math.max(max, k);
    }
    int[] bucket = new int[max + 1];
    for (int k : arr) {
        bucket[k]++;
    }
    int i = 0;
    for (int j = 0; j < bucket.length; j++) {
        while (bucket[j]-- > 0) {
            arr[i++] = j;
        }
    }
}
```

##### 算法分析:

时间复杂度:时间复杂度很好,就是O(n),n是原数组的长度.

空间复杂度:空间复杂度非常不好,是O(max),max是原数组中的最大值,假如原数组是[1,2000],它的桶数组长度还是2001.所以它不适合那些值很离散的数组,他适合那些数据量很大,但是值分布很均匀,重合率很高的数组.

稳定性:整数数组没有不稳定这种说法,稳定性讨论没有意义,硬要说的话就是有稳定性.

评价:它是一个只能处理整数数组的算法,虽然说它可以做到O(n)的时间复杂度,但是有些特殊的数组会产生很大的空间浪费,所以说是否用它一定要考虑原数组的数据量情况.

#### 基数排序

##### 思路:

“基数”,这个概念是针对各种进制而言的,也就是一串数字中,每一位可以表示的范围,比如十进制是10,16进制是16...

这里的基数排序是经典的十进制非负数版本实现,也就是说只能对十进制非负数数组排序.这也体现出非比较排序对数据本身是有要求的这一重大特性.负数虽然不行,但如果数组中有负数时也可以选择修改数组,比如所有值都加上某个数等等很多方法使其满足这个条件.基数不是十的话也可以轻松切换.所以宽泛来讲,这个算法适用于任意进制的整数数组.

最基本的思路是:每个桶都是一个队列,队列的个数就是所谓的“基数”,数组中每个数每轮按`一位的值`进行从小到大的排序,这个排序标准从最低位开始一直到最高位(有的数没有这一位就补0).

因为是队列,所以一定会满足`当前位相等时,低一位也是从小到大的`这一规则.也就是说每一轮都会受到前一轮排序的影响.

但是队列的空间复杂度相对较高,我们能不能把整数队列变为一个数呢?实际上利用前缀和数组是可以做到优化的.但是还是会有缺点,比如说利用队列我们不需要用一个辅助数组来临时存放排序结果.但是这个前缀和数组的方法需要一个和原数组等长的辅助数组.这个算法是从原数组中取一个放一个的做法,需要两个等长数组来回倒,当辅助数组满了就重新倒回原数组,接着排,知道所有位都看完.

具体原理是:还是和队列法一样,根据`位`信息来排序.首先要得出一个前缀和数组,数组的长度是`基数`. 遍历原数组中所有值的“当前参考位”,我们想要的就是该位上每种值个数的前缀和数组.

当我们“从右到左”的从原数组中拿数时,我们看数的“当前参考位”的值是什么,它对应的前缀和数组中的值就是它要在辅助数组中放入的位置,当我们放入一个,其对应的前缀和数组中的值要减1.这也是我们为什么要在原数组中从右往左拿,第一次拿无所谓,都可以,因为数组还一次序都没有排过.但是第二次以及之后就可以看出为什么了,这是因为前一轮已经排过一次序了,我们一定要保证`当前位相等时,低一位也是从小到大的`这一规则.

值的一提的是,前缀和数组中的值除了0位置以外都是不可能减到0的,它的作用是指导我们放好从原数组中拿的值,其中某下标的值代表原数组中某数的“当前参考位”为这个下标时,应该放到辅助数组的哪一位置上.

##### 代码:

```Java
public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        radixSort(arr, 0, arr.length - 1, maxbits(arr));
    }

    public static int maxbits(int[] arr) {
        int max = Integer.MIN_VALUE;
        for (int j : arr) {
            max = Math.max(max, j);
        }
        int res = 0;
        while (max != 0) {
            res++;
            max /= 10;
        }
        return res;
    }

    public static int getDigit(int x, int d) {
        return ((x / ((int) Math.pow(10, d - 1))) % 10);
    }

    public static void radixSort(int[] arr, int L, int R, int digit) {
        final int radix = 10;
        int i = 0, j = 0;
        int[] help = new int[R - L + 1];
        for (int d = 1; d <= digit; d++) {
            int[] count = new int[radix];
            for (i = L; i <= R; i++) {
                j = getDigit(arr[i], d);
                count[j]++;
            }
            for (i = 1; i < radix; i++) {
                count[i] = count[i] + count[i - 1];
            }
            for (i = R; i >= L; i--) {
                j = getDigit(arr[i], d);
                help[count[j] - 1] = arr[i];
                count[j]--;
            }
            for (i = L, j = 0; i <= R; i++, j++) {
                arr[i] = help[j];
            }
        }
    }
}
```

##### 算法分析:

时间复杂度:

- 队列法:放进桶再拿出桶时间复杂度是O(n),n是原数组数据个数,要进行lgMax轮,Max是数组中数据的最大值,lgMax实际上就是所有数据中最大数的位数.每一位都要进行一轮进出桶.所以时间复杂度是O(nlgMax).
- 前缀和数组法:时间复杂度一致.从原数组根据前缀和数组倒到辅助数组以及倒回来的过程也是O(n)的,同样要进行lgMax轮,所以时间复杂度也是O(nlgMax).在实际情况中,lgMax肯定是一个很小的数字,所以我们也可以说时间复杂度是O(n)

空间复杂度:

- 队列法:十个队列每一轮的总空间占用是n.但是实际上每轮数据应该放到哪个队列中都不确定,那最差情况下,每个队列都要准备n的长度的空间,空间复杂度是O(10n).
- 前缀和数组法:要准备一个长度为n的辅助数组以及一个长度为10的前缀和数组.空间复杂度是O(n + 10).肯定是好于队列法的,这还不包括队列本身每个值是作为一个节点存放的,肯定会比一个数组中的纯数要更占空间.所以前缀和数组的算法空间复杂度要优秀的多.

稳定性:

整数数组没有不稳定这种说法,稳定性讨论没有意义,硬要说的话就是有稳定性.

评价:

因为队列法时间复杂度,空间复杂度和前缀和算法一致都是O(n),但是空间占用具体来看差很多,所以我就没有写队列法的实现,遇到这种情况,没有理由用队列法,并且用数组实现比较帅一点.但确实队列法思想会直观很多.

### 桶排序总结

这种桶排序的确可以做到O(n)的排序,这是基于比较的排序肯定做不到的,但是对于数据会有要求,所以如果数据满足使用桶排序的情况下,就使用桶排序.

对于整数数组,使用计数排序虽然时间复杂度很好,也不需要对不是十进制非负数的数据进行特殊处理.但是可能会把空间占用搞成一个完全没有必要的程度,基数排序就是为了解决此问题而存在的,相比于计数排序,基数排序虽然空间复杂度一样都为线性,但是空间占用在特殊情况下可能会小很多很多!

所以针对整数数组,优先使用计数排序,因为比较简单.对空间占用有要求就使用基数排序,最好就是使用前缀数组法的基数排序,相对来说最普适且优秀,应用情况最多,但是也是最复杂的.

---



## 排序中都使用的函数
#### 交换数组中两位置

```java
public static void swap(int[] arr,int i,int j){
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}//朴实版
public static void swap(int[] arr, int i, int j) {
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}//位运算版
```

#### 对输入数组有要求

```Java
if (arr == null || arr.length < 2){
    return;
}
```

